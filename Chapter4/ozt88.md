# 점과 벡터

> 점과 직교 좌표계
* 점: n차원 공간에서의 위치
* 직교좌표계: 서로 직교하는 축을 이용해 공간상에 위치를 표시하는 일반적인 좌표계
* 기타 좌표계
    * 원통 좌표계: 높이(h)와 h에 수직인 반지름 축(r), 수평각도(th)
    * 구면 좌표계: 수직각도(pi), 수평각도(th), 반지름(r)
* 당면한 문제를 제일 잘 나타내느 좌표계를 골라서 사용하면 좋다
    * 주인공 캐릭터를 원통 모양으로 회전하는 애니메이션에 원통 좌표계가 유용

> 왼손 좌표계 & 오른손 좌표계
* 삼차원 직교좌표계에서 서로 직교하는 세 축을 표현하는 두가지 방법
* z축을 양의 방향으로 감싸쥐는 손이 무엇이냐에 따라 x, y순서가 바뀐다.
    * y축이 머리위, x축이 오른쪽을 가리킬 때, z축이 다가오는 방향이면 오른손, 아니면 왼손
    * 두 축을 고정했을때 다른 한 축의 방향이 서로 반대
* 계산 규칙에 영향을 주지 않고, 계산된 숫자에 대한 해석, 시각적 표현만 달라진다. (외적 빼고)
* 어떤 걸 선택할 거냐는 프로그래머의 마음이다. 일관적으로 사용하는게 중요하다.
* 3D 그래픽 플머는 왼손좌표계를 많이쓴다. 카메라 기준 y 위, x 오른쪽, z 멀어지는 깊이(z-buffer)

> 벡터
* 벡터: n 차원 공간에서 크기와 방향을 나타내는 값, 방향이 있는 선
* 스칼라: 방향은 없고 크기만 있다.
* 점은 절대적 위치, 벡터는 상대적 차이
    * 벡터의 꼬리를 좌표계의 원점에 두면 벡터는 위치벡터로 기능
    * 동차 좌표계에서 점과 벡터는 서로 다르게 취급된다. [x, y, z, 0 or 1]
* 기저 백터: 직교 좌표계의 각 축 방향인 단위 벡터
    * 3차원의 단위벡터는 보통 [i, j, k] 로 표현한다.
    * 모든 점과 벡터는 기저 벡터의 스칼라 곱의 합으로 표현 할 수 있다.

> 벡터 연산
* 스칼라 값과의 곱
    * v = [x, y, z];
    * v * s(스칼라) == [sx, sy, sz];
    * 크기는 증가하고 방향은 그대로 (음수인 경우 방향이 반대로)
    * 불균등 스케일 값을 곱하는 경우는 아다마르 곱셈이라고 표현 [s1*x, s2*y, s3*z]
    * 3x3 스케일 행렬 연산으로 표현할 수 있다.
* 벡터간 덧셈 뺄셈
    * v1 = [x1, y1, z1];
    * v2 = [x2, y2, z2];
    * v1 + v2 == [x1 + x2, y1 + y2, z1 + z2];
    * v1 - v2 == [x1 - x2, y1 - y2, z1 - z2];
    * 벡터의 합은 좌항의 머리에 우항의 꼬리를 가져다 놓은 모양을 상상하면 된다.
* 벡터와 점의 덧셈 뺄셈
    * 점 + 벡터 = 다른 점
    * 점 - 점 = 벡터
    * 점 + 점 = undefined
* 벡터의 크기 |v|
    * v = [x, y]
    * |v| == sqrt(x^2 + y^2);
* 벡터 연산의 활용
    * 명시적 오일러 적분
        * p = 캐릭터의 현재 위치 (점)
        * v = 캐릭터의 현재 속도 (벡터)
        * 다음 프레임의 캐릭터의 위치 = p + v * deltaTime
    * 구의 교차 체크
        * 구의 중심 (점) c1, c2
        * 구의 반지름 (스칼라) r1, r2
        * 중심간의 방향 벡터 d = c1 - c2
        * 구의 교차 == |d| < r1 + r2
* 정규화(normalize)와 단위 벡터(unit vector)
    * 단위 벡터(u): 크기가 1인 벡터
    * 3d 수리 연산과 게임 프로그래밍에서 중요하게 사용된다.
    * 정규화: 벡터를 단위 벡터로 만드는 것
    * u = v / |v|
* 법선 벡터 (normal vector)
    * 평면에 수직인 벡터
    * 3d 수리 연산과 게임 프로그래밍에서 유용하게 사용된다.
    * 한 점과 법선 벡터로 평면을 정의 할 수 있다.
    * 면과 면에 비치는 상대적 각도를 계산하는데 자주 사용된다.
* 내적(dot product)
    * 연산 결과가 스칼라 값
    * v1 * v2 == x1 * x2 + y1 * y2 + z1 * z2;
    * v1 * v2 == |v1| * |v2| * cos(두 벡터가 이루는 각도)
    * v1 * v2 == v2 * v1 (교환 법칙)
    * v1 * (v2 + v3) == v1 * v2 + v1 * v3 (분배 법칙)
    * s(스칼라) * v1 * v2 == v1 * s * v2 == s * (v1 * v2)
* 내적 응용
    * 단위 벡터(u)와 임의의 벡터(v)의 내적은 v를 u의 연장선상으로 투영한 크기가 된다.
    * 벡터 크기 구하기 
        * v * v == |v| * |v| * cos(0) == |v|^2
    * 두 벡터의 관계
        * 평행인 같은 방향 벡터 a * b == |a| * |b|
        * 평행인 다른 방향 벡터 a * b == -1 * |a| * |b|
        * 수직인 벡터 a * b == 0
        * 두 벡터가 이루는 각이 90도 미만 a * b > 0
        * 두 벡터가 이루는 각이 90도 이상 a * b < 0
    * 게임에서 활용
        * 적이 플레이어의 앞에 있는지 확인하고 싶을 때
            * 플레이어의 위치 p
            * 적의 위치 e
            * 플레이어의 방향 벡터 v
            * 앞에 있는가? == v * (e - p) > 0
        * 평면과 점의 사이의 거리
            * 평면 위의 점 q, 평면의 법선 단위 벡터 n
            * 임의의 점 p
            * 평면과 점 사이의 거리(h) == (p - q) * v
* 외적(cross product)
    * 연산 결과가 벡터
    * v1 x v2 = [(y1*z1 - z1*y2), (z1*x1 - x1*y2), (x1*y2 - y1*x2)]
    * |v1 x v2| = |v1| * |v2| * sin(두 벡터가 이루는 각도)
    * 외적의 크기는 v1, v2를 두변으로 하는 평행 사변형의 크기와 같다
    * p1, p2, p3 세점으로 구성된 삼각형의 넓이 == 두 변으로 이뤄진 두 벡터 외적의 크기 / 2
    * 외적의 방향은 왼손 / 오른손 좌표계에서 두 벡터를 순서대로 감싸쥔 엄지의 방향
    * v1 x v2 != v2 x v1
    * (v1 x v2) x v3 != v1 x (v2 x v3)
    * v1 x v2 == (-1 * v2) x v1
    * v1 x (v2 + v3) == (v1 x v2) + (v1 x v3)
    * (s * v1) x v2 == v1 x (s * v2) = s * (v1 x v2)
    * 직교 좌표계의 축간의 외적은 좌표계의 축에 대한 양의 회전 방향을 정의한다.
        * i x j == k, j x k == i, k x i == j
        * z축에서 양의 회전은 x축에서는 y방향 ...
* 외적의 활용
    * 두 벡터의 수직인 벡터를 찾을때 외적을 사용
    * 어떤 로컬 기저 좌표 벡터의 두 값을 알고 있을 때 나머지 하나를 구하는데 사용
        * 위, 오른쪽 알면 진행 방향을 구할 수 있음
    * 삼각형이나 평면의 단위 법선 벡터를 구할때도 사용
    * 토크 계산할 때 사용
        * 가해진 힘 F
        * 물체의 무게 중심으로부터 힘이 가해진 점 사이의 거리 R
        * 토크 == R x F
* Linear Interpolation (LERP)
    * 두 지점 사이에서 0 ~ 1로 보간한 위치 계산
        * 점 A, B
        * 보간 값 x (0~1)
        * 보간 위치 p == (1 - x)*A + x*B

# 행렬

> 행렬이란
* m x n 개의 스칼라 값을 사각형 형태로 나열한 것
* 평행이동 회전변환 같은 선형 변환을 표현하기에 편리
* 행렬은 스칼라값의 집합을 대괄호로 묶어서 표현
* 3 x 3 행렬의 각 행과 열을 3d 벡터로 생각할 수 있다.
* 모든 행과 열을 구성하는 벡터가 단위 벡터인 경우, 이 행렬을 특수 직교 행렬이라 한다.
* 변환 행렬
    * 평행 이동, 회전 변환, 스케일 같은 임의의 3d 변환을 4 x 4 행렬로 표현한것
    * 변환 행렬은 게임 엔진에서 가장 요긴하게 사용되는 행렬
    * 점과 벡터를 변환 행렬과 곱하는 것으로 원하는 변환이 가능

> 행렬 곱셈 
* 행렬 A와 B의 곱 P는 AB로 표현
* A B 가 변환 행렬인 경우 P는 두가지 변환을 합한 또다른 변환행렬이 된다.
* 여러 변환행렬을 미리 계산하고 한개의 행렬에 저장해 놓고 벡터들에 곱해서 효율을 올릴 수 있다.
* 행렬의 곱셈은 Na x Ma 행렬 A의 열과 Nb x Mb 행렬 B의 행을 벡터 내적하면 된다.
* 내적한 결과는 곱셈의 결과가 되는 P 행렬의 한 성분이 된다.
* 행렬 곱셈이 성립하려면 앞선 벡터의 열 갯수와 뒤 벡터의 행 개수가 같아야 한다.
* 행렬 곱셈은 교환 법칙이 성립하지 않는다. 곱하는 순서에 따라 결과가 달라진다.
* 행렬 곱셈은 concatenation 이라고 불리기도 한다. 

> 점과 벡터를 행렬로 표현
* 점과 벡터는 행이 하나인 행 행렬이나 열이 하나인 열 행렬로 표현할 수 있다.
* 열 벡터, 행 벡터를 쓸지는 취향인데 행렬 곱셈의 순서에 영향을 미친다.
    * 열벡터는 곱셈의 좌항에 와야 한다.
    * 행벡터는 곱셈의 우항에 와야 한다.
* 변환 행렬 A, B, C가 순서대로 행렬벡터 v를 변환한다고 한 경우
    * 열 벡터는 오른쪽에서 왼쪽으로 CBAv 결합해야한다.
    * 행 벡터는 왼쪽에서 오른쪽으로 vABC 결합해야한다.

> 단위 행렬
* 단위 행렬이란 다른 행렬에 곱했을때 결과가 변하지 않는 행렬이다.
* I 로 표기하고 행과 열의 수가 같고 대각선 성분만 1이고 나머지 0이다.

> 역행렬
* 어떤 행렬의 연산을 완전히 되돌리는 행렬을 그 행렬의 역행렬이라 부르고 A^-1로 표기한다.
* A가 z축으로 37도 회전 변환하는 행렬이라면 A^-1은 z축 방향으로 -37도 회전하는 행렬이다.
* 행렬과 그 역행렬을 곱하면 단위 행렬이 된다.
* 모든 행렬에 역행렬이 있는 것은 아니다.
* 가우스 소거법이나 LU 분해법을 이용하면 역행렬을 찾을 수 있다 (존재하는 경우)
* 행렬을 여러개 곱한 것의 역행렬은 각 행렬의 역행렬을 역순으로 곱한 것이다.
    * (ABC)^-1 == C^-1 B^-1 A^-1

> 전치 행렬
* 행렬 M의 전치행렬은 M^T로 표현한다.
* 전치 행렬은 원래 행렬을 대각선 기준으로 뒤집어 놓은 것이다. 
    * 전치 행렬은 원래 행렬의 열과 행을 역전한 것이다.
* 전치행렬은 유용하다
    * 정규 직교 행렬의 역행렬은 전치 행렬과 같다.
    * 전치 행렬이 역행렬보다 구하기 쉽다.
    * 열 벡터 기준 라이브러리를 행 벡터 기준 라이브러리로 변환할때
        * 변환행렬을 전치 행렬로 변환하면 된다.
    * 행렬 곱에 대한 전치 행렬은 각 행렬의 전치 행렬들을 역순으로 곱한 것과 같다.
        * (ABC)^T == C^T B^T A^T

> 동차 좌표 (Homogeneous Cordinates)
* 3 x 3 행렬로 3차원 평행이동을 표현할 수 없다.
    * r + t = [(rx + tx), (ry + ty), (rz + tz)]
* 4 x 4 행렬로는 가능하다.
    * 회전 변환이 되면 안되므로 위쪽 3 x 3 부분은 단위 행렬이 되야 한다.
    * 행렬 맨 아래 열에 t의 성분을 배치하고 r의 네번째 성분을 1로 두면
    * 첫번째 열의 내적은 rx + tx 가 된다.
    * 이 행렬의 네번째 열의 가장 아래 성분만 1로 두고 나머지는 0으로 두면 
    * 곱셈 결과 벡터도 w가 1이된다.
* 3 차원 점이나 벡터를 이런 식으로 4차원으로 확장한 것을 동차 좌표로 표현했다고 한다.
* 동차 좌표의 모든 점은 w = 1이다.
* 게임 엔진에서 사용하는 거의 대부분의 3D연산은 이 동차 좌표로 표현된 연산이다.

> 방향 벡터 변환
* 수학적이 관점에서 점과 방향 벡터는 다르게 취급된다.
* 행렬을 통해 점을 변환할 때는 평행 이동, 회전 변환, 스케일이 모두 적용된다.
* 방향 벡터를 변환할 때는 평행 이동이 무시된다. (벡터에 평행이동 개념이 없기 때문)
* 동차 좌표에서 벡터의 w를 0을 두는 것으로 평행이동 무시하는 연산이 가능해진다.
* 동차 좌표의 점을 일반적인 3차원 좌표계로 바꾸려면 x, y, z 각 성분을 w로 나누면 된다.
* w = 0인 벡터는 무한대의 위치를 갖는 점과 같은 역할을 한다.

> 기본 단위 행렬 변환
* 아핀 변환
    * 순수한 * ( 평행이동, 회전 변환, 스케일, 층밀림 ) 변환을 결합
* 아핀 변환의 요소
    * 위쪽 3 x 3 행렬 U: 회전변환과 스케일변환을 표현
    * 아래쪽 1 x 3 평행 이동 벡터 t
    * 오른쪽 3 x 1 영 벡터 0
    * 오른쪽 아래 스칼라 값 1
* 평행 이동 변환 - skip
* 회전 변환
    * 왼쪽 위 3 x 3 행렬 R은 회전 각도에 대한 코사인 값과 사인 값으로 구성된다. 
    * w 를 제외한 나머지 값은 0이다
    * x, y, z축에 대한 회전 변환은 서로 다르다. (교재 참조)
    * 1은 항상 회전하는 축에 해당하는 성분에 곱해진다. 나머지는 사인과 코사인이다.
    * 양의 회전 방향
        * z축에 대해서는 x축에서 y축으로
        * x축에 대해서는 y축에서 z축으로
        * y축에 대해서는 z축에서 x축으로
    * 회전 변환의 역은 전치 행렬과 같다.
        * 거꾸로 회전한 것은 회전 각도의 부호를 반대로 한 것이기 때문이다.
        * cos(-theta) == cos(theta) && sin(-theta) == -sin(theta)
* 스케일 변환
    * 스케일 행렬의 역은 각 스케일 값을 역수로 바꾸면 된다.
    * 세 축에 대한 스케일 인수가 같은 경우 uniform 스케일이라고 한다.
    * 고른 스케일 행렬과 회전 변환을 결합할때 교환 법칙이 성립한다.

> 4 x 3 행렬
* 아핀 행렬에서 가장 오른쪽 행은 언제나 [0 0 0 1] 이므로 자주 생략한다.
* 게임에 사용되는 수학 라이브러리에서는 4 x 3 아핀 행렬을 쉽게 볼 수 있다.

> 좌표 공간
* 좌표 공간이란
    * 점과 벡터에 대한 변환 행렬을 응용하면 rigid body 변환에도 적용할 수 있다.
    * rigid body는 물체를 이루는 모든 점을 변환하는 것과 같다.
    * 절대적인 좌표의 점은 원점에 꼬리를 둔 벡터로 표현 할 수 있다.
    * 점을 어떤 좌표계에 상대적인 값으로 볼 수 있다.
    * 좌표계를 바꿀 때마다 점을 구성하는 값이 변화한다.
    * 어떤 좌표축의 모임을 게임에서 좌표 공간이라고 말한다.
* 모델 공간
    * 메시의 삼각형의 정점들은 특정한 직교 좌표계를 기반으로 만들어 진다.
    * 이를 모델 공간이라고 부른다.
    * 모델 공간의 원점은 보통 물체의 중심에 위치하지만 용도에 따라 변경되기도 한다.
        * 사람이나 동물의 메시는 발이 닫는 지면을 사용하기도 한다.
    * 대부분의 게임에서 사용되는 물체들은 고유한 방향성이 있다.
        * 앞(F): 물체가 이동하거나 얼굴이 향하는 기저 벡터
        * 위(U): 물체의 위쪽이 향하는 단위 기저 벡터
        * 왼쪽(L) or 오른쪽(R): 왼손 좌표계나 오른손 좌표계에서 사용되는 기저 벡터
        * 오른손 좌표계에서 앞을 z, 왼쪽은 x, 위는 y로 표현한다.
    * 좌표계의 축에 이름을 붙여 혼란을 줄인 오일러 각
        * pitch: L or R 기준 회전
        * yaw: U를 기준으로 회전
        * roll: F를 기준으로 회전
* 월드 공간
    * 월드에 존재하는 모든 물체의 위치, 방향, 스케일 값이 표현되는 정해진 좌표공간
    * 모든 물체를 단일한 가상 공간에 존재하게 하는 역할
    * 보통 게임플레이 공간의 중심에 원점을 두어 x, y, z의 절대값을 줄인다.
    * x, y, z 좌표 축도 마음이지만 y를 위, x를 오른쪽으로 하면 마음이 편하다 (주관적)
    * 모델 공간의 좌표는 월드공간상에서 모델 공간 원점의 평행 이동 변환으로 구할 수 있다.
* 뷰 공간
    * 뷰 공간은 카메라에 고정된 좌표 공간이다.
    * 원점은 카메라의 초점이다.
    * 좌표축은 맘대로지만 y축이 위로, z축이 카메라가 바라보는 방향인 좌표계가 마음 편하다.
    * z축이 화면의 깊이를 표현하는 값으로 사용되면 편리하다.
    * openGL은 오른손 좌표계로 카메라가 향하는 방향이 z축의 음의 방향이다. (으)

> 기저 변환
* 어떤 물체의 위치, 방향, 스케일을 다른 좌표계의 값으로 바꾸는 것을 기저 변환이라고 한다.
* 좌표 공간의 계층
    * 어떤 좌표 공간의 위치와 방향 스케일 값은 다른 좌표축들에 상대적인 값이다.
    * 좌표공간들은 계층이 있다.
    * 모든 좌표공간은 어떤 좌표공간의 자식이다.
    * 월드 공간은 모든 좌표공간의 root이다.
* 기저 변환 행렬
    * 자식 좌표 공간의 x, y, z축 기저벡터를 부모 좌표공간에서의 값으로 표현, i, j, k
    * 부모 좌표 공간에서 자식 좌표 공간의 평행이동값 t
    * [i, j, k, t]^T 가 4 x 3 기저 변환 행렬이다 4 x 4는 [0, 0, 0, 1] 열 넣으면됨
    * i, j, k 로 구성된 3 x 3행렬은 회전 변환 행렬이다.
        * 2차원의 예 4.20
    * 스케일 넣을라면 i, j, k를 스케일하면됨
* 행렬에서 단위 기저 벡터 구하기
    * 거꾸로 기저 변환 행렬을 알면 자식의 좌표 공간 기저 벡터를 찾을 수 있다.
    * 모델-월드 아핀 변환 행렬이 있다면, 모델의 각 기저 벡터는 걍 위치대로 뽑아내면 된다.
* 좌표계 변환과 벡터 변환
    * 자식 - 부모 벡터 변환은 부모 - 자식 좌표계 변환이다
    * 햇갈리니깐 벡터 변환만 생각하자
    * 익숙해지면 용도에 맞게 생각하면 이해하기 쉬운 경우가 있다.

> 법선 벡터 변환
* 법선 벡터 변환할때는 길이와 수직조건을 보존하기 위해 주의를 기울일 것
* 법선 벡터 n을 공간변환하려면 공간 변환 행렬(M)의 역전치 행렬((M^-1)^T)을 곱해야한다.
* 공간 변환 행렬에 직교변환이 아닌(균등하지 않은 스케일이나 층밀림)변환을 포함할 때
    * 표면과 벡터간 각도가 보전되지 않는다.
    * 공간 A에서 수직이던 벡터는 공간 B에서 수직이 아닐 수 있다.
* 역 전치 행렬을 사용하면 변환된 법선 벡터의 성질을 보존할 수 있게 교정하는 역할을 한다.


> 행렬을 메모리에 저장하는 방식
* 2차원 배열을 사용해서 저장한다. 
* 첫번째 인덱스는 행, 두번째는 열이다.
* 메모리 공간 순서는 열 -> 행 순이다.
* 벡터 (i, j, k, t)를 행 or 열로 담을 수 있다.
* 행으로 담는것이 각 벡터를 뽑아내기 편해서 좋아보인다.
    * float M[4][4];
    * M[0][0]=ix; M[0][1]=iy; M[0][2]=iz; M[0][3]=0;
    * M[1][0]=jx; M[1][1]=jy; M[1][2]=jz; M[1][3]=0;
    * M[2][0]=kx; M[2][1]=ky; M[2][2]=kz; M[2][3]=0;
    * M[3][0]=tx; M[3][1]=ty; M[3][2]=tz; M[3][3]=1;
* 열로 담으면 SIMD 연산(??)이 가능한 연산기에서 행렬 벡터 곱을 빠르게 할때 좋단다
* 평행이동 행렬을 만드는 코드에서 t벡터가 어디에 저장되는지 보면 행인지 열인지 알 수 있다.









    
