# 소개
## 엔진?
- 코어부분은 공통적인 패턴이 많음. 엔진간의 차이는 A, A', A'' 같은 느낌.
- 주요 구성부분은 렌더링, 물리, 애니메이션, 오디오, 게임 객체 모델, 인공지능 시스템 등.

## 게임이란
- 사용자에게 점진적으로 난이도가 증가하는 도전 과제를 제시하고, 사용자가 궁극적으로 그 과정을 학습하고 숙달하는 상호적인 경험을 제공하는 행위 - Raph Koster

## 런타임 게임 아키텍쳐
### 목표 하드웨어
- 게임이 동작할 기기
###  디바이스 드라이버
- OS나 디바이스 벤더에서 제공하는 low-level 소프트웨어
### 운영체제
### 서드파티 SDK / 미들웨어
- 자료구조와 알고리즘
-- STL
-- STLPort: 크로스플랫폼에 최적화된 STL
-- Boost
-- Loki: 아주 복잡하고 강력한 제네릭 프로그래밍 템플릿 라이브러리
- 그래픽스
-- OpenGL
-- DirectX
- 충돌과 물리
-- Havok
-- PhysX
-- Open Dynamics Engine (ODE): 오픈소스 물리,충돌 패키지
- 캐릭터 애니메이션
-- Granny: 가장 잘 설계되고 논리적인 애니메이션 API라는 역자피셜.
-- Havok Animation: 물리와 애니메이션간 구분 줄이는데 큰 역할 함.
-- Edge: PS3용
- 인공지능
-- Kynapse: 길 찾기, 정적/동적 충돌 회피, 공간 내 취약점 감지 등 기본적인 인공지능 개발 도구 제공 및 AI-애니메이션간 훌륭한 인터페이스 구현
- 생체 역학적 캐릭터 모델
-- Endorphin and Euphoria: 인체 움직임을 첨단 생체 역학적 모델로 분석해 캐릭터 애니메이션 만들어내는 패키지

### 플랫폼 독립적 계층
- 하드웨어, 드라이버, OS, SDK 등의 바로 위에서 동작. 엔진이 하드웨어에 종속적이지 않게 하기 위한 계층임. 보통 크로스플랫폼을 위한 API 래핑을 여기서 하는 듯.

### 코어 시스템
- 엔진의 코어. 다음과 같은 예시가 있음.
-- Assertion
-- 메모리 관리
-- 수학 라이브러리
-- 독자적 자료 구조와 알고리즘

### 자원 관리자
- 엔진의 자원과 데이터에 접근하는 인터페이스 제공

### 렌더링 엔진
- low-level 렌더러
-- Geometric primitive를 가능한 빠르게 그리면서 다양한 방식을 지원하걸 중점으로 둠. 화면의 가시성 등 추상적인 문제엔 관여안함.
-- 그래픽 디바이스 인터페이스: OpenGL, DirectX 등 SDK마다 다르지만 디바이스 세팅이랑 렌더링 초기화하는 부분.
- 장면 그래프와 추려내기 최적화
-- 그려질 가능성이 있는 녀석들을 추려내서 연산 줄이기.
-- 작은 월드는 Frustum Cull로도 충분
-- 큰 월드는 공간 분할을 이용. (Potentially visible set을 이용)
-- BSP Tree, Octree, KD Tree, Sphere hierachy 등의 방법이 있음.
- 시각 효과
-- 파티클 시스템
-- 데칼 시스템(총알자국, 발자국 등)
-- 조명 매핑과 환경매핑
-- 동적 그림자
-- 후처리 (HDR, Bloom, FSAA, ...)
- 전단부
-- HUD
-- 게임 메뉴, 콘솔, 기타 개발 툴
-- GUI
-- In-game cinematics
### 프로파일링과 디버깅 툴
- 시중의 훌륭한 디버깅 툴 (Intel VTune, IBM Quantify/Purify, Compuware Bounds Checker, ...)
- 근데 보통 아래와 같은 기능들을 자체 구현함.
-- 코드 수동 instrumentation (소모된 시간 측정)
-- 인게임 화면에서 실시간으로 프로파일링 수치 보여주기
-- 측정 결과를 파일로 출력
-- 엔진이 사용중인 메모리 양 측정하는 기능
-- 메모리에 관련된 기록과, 언제든지 파일로 뽑을 수 있는 기능
-- 디버깅 메세지를 코드 어디서나 출력할 수 있고, 어느 정도로 세부적이게 출력할지 정할 수 있는 기능
-- 게임 플레이 녹화하고 재현하는 기능
### 충돌과 물리
- 보통 이건 외부 SDK를 많이 씀 (Havok, Physics, ODE, ...)
### 애니메이션
- 가장 기본적인 방식 5가지
-- 스프라이트/텍스쳐 애니메이션
-- Rigid body 애니메이션
-- Skeletal 애니메이션
-- Vertex 애니메이션
-- Morph target
### HID
- 입력 장치를 의미
- 키보드,마우스 / 조이패드 / 기타 특수한 컨트롤러들
### 오디오
### 네트워킹
- 싱글 -> 멀티는 굉장히 어려우므로 멀티는 미리미리 고려해두고 설계할 것
### 게임플레이 기반 시스템
- 게임 월드와 객체 모델
-- 객체를 설계할 때 고려해야 할 문제들
-- 1. 엔진 디자인이 객체지향적인가?
-- 2. 어떤 개발 언어를 사용할 것인가?
-- 3. 클래스 구조는 어떻게? 거대한 한 개의 수직적 구조 vs 연관성 적은 수평적 구조
-- 4. 템플릿과 정책 기반(????) 디자인을 사용할 것인지 다형성 사용할 것인지.
-- 5. 객체 접근할 때 포인터, 스마트포인터, 핸들 등 어떻게 할 것인가?
-- 6. 서로 다른 객체를 어떻게 고유하게 분별할 것인가? (물리적 주소, 이름, GUID 등)
-- 7. 객체 수명 관리 어떻게?
-- 8. 시간의 흐름에 따른 객체 상태 어떻게 시뮬레이션 할거냐
- 이벤트 시스템
- 스크립트 시스템
- 인공지능 기반 시스템
### 게임 특화 하부 시스템
- 게임(엔진) 특성에 따른 특화적인 시스템을 구축

## 툴과 자원 파이프라인
### 디지털 컨텐츠 생성 도구(DCC)
- 게임에 쓰이는 리소스들 편하게 생성하는 도구
### 자원 다듬기 파이프라인
- DCC에서 생성된 리소스는 과한 데이터를 포함하고 있어서 그대로 사용하면 굉장한 낭비다.
- 그래서 필요한 데이터만 추출하고 가공해서 써야함
### 3D 모델 / 메시 데이터
- 기하 형태는 크게 두 가지로 나뉨.
- 브러시 기하 형상
-- 평면 여러개로 이뤄진 Convex hull
-- 빠르고 만들기 쉽다
-- 게임 디자이너가 쉽게 사용 가능(프로토타이핑용?)
-- 충돌 볼륨 역할도 가능
-- 하지만 복잡하게 만드는건 어려움
-- 관절, 활동적인 물체 표현도 어려움
- 3D 모델(메시)
-- 삼각형과 정점으로 이뤄진 모양을 가진 형태
### 뼈대 에니메이션 데이터
- 스켈레탈 메시를 그리기 위해선 세 가지가 필요
-- 1. 메시
-- 2. Skeletal 구조
-- 3. 뼈대 애니메이션
- 애니메이션 용량이 굉장히 크기 때문에 압축이 중요
### 오디오 데이터
- wav를 가장 널리 씀
### 파티클 시스템 데이터
### 게임 월드 데이터 / 월드 에디터
- 훌륭한 월드 에디터들
-- Radiant
-- Hammer
-- UnrealEd
### 툴 구조에 대한 접근 방식
- 게임 엔진에서 툴은 독자적으로 존재하거나, 코어를 공유하는 두 가지 모양임.
- UnrealEd처럼 툴과 엔진이 완전히 통합되어 있으면 장점도 많지만 단점도 많다. 엔진과 DCC는 너무 밀접하면 오히려 생산성 떨어트림.
