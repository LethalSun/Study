# 1장 소개

## 게임엔진이란 무엇이고 어떤 목적으로 만들어 졌는가?

### 게임이란?

* 사용자에게 점진적으로 난이도가 증가하는 도전과제를 제시하고, 사용자가 궁극적으로 그 과정을 학습하고 숙달하는 상호 경험을 제공하는 행위

> 실시간 시뮬레이션
* 세상을 수학적으로 모델화
    * 근사화와 단순화를 통한 실 세계의 시뮬레이션
* 행위자 기반의 시뮬레이션 
    * 서로 다른 행위자들의 상호작용
    * 객체지향적 프로그래밍 언어에 적합하다
    * 사용자의 조작에 실시간으로 반응하는 상호적 시뮬레이션
* 시간적 시뮬레이션
    * 시간과 진행도에 따라 동적으로 변화하는 가상 세계의 구현
* 시간 제약
    * 움직이는 것 처럼 보이기 위해 초당 최소 24번의 업데이트가 필요
    * 물리 엔진의 안정성을 보장하기 위해 초당 최소 120번 업데이트 필요
    * AI의 빠른 반응을 위해 초당 한번씩 '생각' 할 수 있어야한다.
    * 오디오가 끊어지지 않게 초당 60번씩 버퍼를 채워줘야 한다.
    * 하지만 오직 재미를 위한 덜 엄격한 실시간 시스템
* 수치적 수학 모델을 기반
    * 예측 불가능한 유저의 움직임
    * 수치적인 시뮬레이션을 통해 이산적으로 상태 업데이트
    * 메인 루프 속에서 AI, 게임 로직, 물리 등의 컴포넌트 업데이트

### 게임 엔진이란?

> ID 소프트의 '둠' 에서 유래
* 게임 제작에 필요한 코어 소프트웨어들과 사용자가 보는 게임 관련 요소를 분리해서 설계
* 최소한의 엔진(코어 소프트웨어) 변경만으로 게임 관련 요소들을 변경함으로서 완전 새로운 게임을 만들 수 있다.
* 모드 커뮤니티의 탄생
* 엔진 재사용 / 모드 제작을 염두에 두고 설계된 게임들이 등장
* 엔진의 사용화가 수입을 벌어들이기 시작함

> 게임과 게임엔진의 구별
* 오크 렌더링의 사례
    * 렌더링 엔진안에서 직접 오크를 그린다. (게임)
    * 범용적인 머테리얼과 세이딩 기능을 제공하고 오크적인 특징은 데이터로 정의 (엔진)
* data driven 설계, 변경가능한 재사용성
* 엔진이란 핵심적인 변화 없이도 다른 게임을 만들수 있는 확장 가능한 소프트웨어
* 재사용성을 얼마나 담보하는지에 따라 엔진으로서의 기능성이 확대된다.
* 모든 게임을 만들 수 있는 범용적 소프트웨어는 없다. (아직까지는)
* 플렛폼과 하드웨어의 측면에서
    * 범용적으로 지원할 수록 재사용성이 증대
    * 특정 플렛폼과 하드웨어에 최적화 감소
* 균형과 선택
    * 실내와 실외 환경을 렌더링하는 최적화 기법은 서로 다르다.
    * 상대적으로 적은 오브젝트가 있는 실내는 차폐에 신경쓰고
    * 원근이 있는 실외는 lod에 신경쓴다.
    * 범용성과 최적화 간의 균형과 선택은 중요한 문제이다.

### 장르별 게임 엔진

> FPS
* 사용자를 사실적인 환경에 몰입시켜야 한다.
* 광활한 3D의 효율적 렌더링
* 즉각적 카메라 조작과 조준
* 팔과 무기 애니메이션
* 1인칭 움직임과 충돌 구현
* 사실적인 NPC 애니메이션

> 플렛포머 또는 3인칭 시점
* 메인캐릭터의 능력이나 이동방식을 강조
* 캐릭터의 전신을 사실적으로 표현해야한다.
* 움직이는 발판이나 사다리등의 흥미로운 이동방식
* 퍼즐이 가득한 배경
* 3인칭 시점 카메라
* 시야를 보장하는 카메라 충돌 시스템

> 격투 게임
* 풍부한 격투 애니메이션
* 정확한 타격 감지
* 복잡한 입력 처리
* 정적인 배경
* 뛰어난 캐릭터 그래픽

> 레이싱 게임
* 먼 배경을 사실적으로 그리기 위한 눈속임 (빌보드)
* 렌더링 최적화, AI, 시야 결정을 위한 트랙을 구획 
* 1차원 3차원 변경가능한 카메라
* 시야를 보장하는 카메라 충돌 처리

> RTS
* 먼곳을 볼 수 없게 카메라 각도 제한
* 제한된 카메라 각도에 최적화된 렌더링 방식 (직교투영과 그리드 시스템)
* 많은 수의 유닛이 한화면에 나오는 경우에 대한 대비
* 높이가 있는 지형구현 (높이 필드)
* 병력 조종, 건물 건설 기능
* 마우스 입력처리, UI 

> MMO
* 게임 월드의 상태를 유지하는 게임 서버
* 로그인, 로그아웃, 유저간 커뮤니케이션 제공
* 거래 기능을 위한 별도의 서버
* 큰 월드와 많은 유저를 그릴 수 있는 최적화된 렌더링 기능

> 다양한 장르의 구현
* 게임 장르마다 요구사항이 상이
* 하지만 공통적인 부분은 언제나 존재한다.
* 게임 하드웨어가 통합됨에 따라 게임 엔진의 재사용성이 증대

### 상용 엔진

> 퀘이크 계열
* FPS에 강력한 구조

> 언리얼 엔진
* 강력한 셰이더 편집 도구
* 게임 로직을 GUI인터페이스로 편집가능

> 하프라이프 소스 엔진

> XNA 게임 스튜디오
* c#기반
* 비주얼 스튜디오안에서 소스코드와 게임 리소스까지 관리됨

> 기타 등등

## 게임 엔진의 구성요소

### 런타임 게임 아키텍처

> 목표 하드웨어
* 게임이 동작할 컴퓨터나 콘솔 시스틈
* PC, 아이폰, mac, xbox, ps, 닌텐도DS, 게임큐브, wii

> 디바이스 드라이버
* 운영체제
* 하드웨어 제조사에서 제공한느 로우레벨 소프트웨어
* 소프트웨어에서 하드웨어를 쉽게 컨트롤 할 수 있게 도와준다.

> OS
* 윈도우는 여러 어플리케이션간 하드웨어 자원을 선점형으로 분배
* 게임이 모든 하드웨어를 독점할 수 없고 다른 프로그램의 존재를 염두에 두어야 한다.
* 콘솔에서는 하드웨어를 게임이 독점한다. 최근엔 많이 바뀜

> 서드파티 SDK, 미들웨어
* 자료구조와 알고리즘
    * STL, Boost, Loki
    * STL은 메모리 단편화를 유발할 수 있으나 편리
    * PC의 가상메모리는 단편화를 완화할 수 있으나 콘솔은 그렇지 않다
    * 직접 메모리 특성이 좋은 자료구조를 구현하는 것이 좋을 수도 (지금도?)
* 그래픽스
    * 렌더링 엔진은 하드웨어 인터페이스 라이브러리 위에서 동작
    * Glide, OpenGL, DX, libgcm, Edge
* 충돌과 물리
    * 충돌감지, 강체 역학 기능 지원
    * Hovok, PhysX, ODE
* 캐릭터 애니메이션
    * 그래니
        * 마야 맥스등 제작도구를 위한 모델 애니메이션 내보내기 도구 지원
        * 지은이 추천
    * 하복 애니메이션
        * 애니메이션에서 물리를 보완
    * Edge
* AI
    * 키냅스 - 충돌 회피, 길찾기, 취약점 감지등의 공통 AI 개발 도구 제공
* 생체 역학적 캐릭터 모델
    * Endorphin, Euphoria
    * 인체 움직임을 생체 역학적 모델로 분석해서 캐릭터 에니메이션을 만들어냄

> 플렛폼 독립적 계층
* 여러 플렛폼에서 동작을 보장하기 위해 플렛폼에 독립적인 계층을 둔다.
* C 라이브러리 함수, OS관련 함수, 기반 계층 API를 래핑 또는 대체해서 일관성 있는 동작을 보장한다.

> 코어 시스템
* C++ 개발에 필요한 소프트웨어 유틸리티
* Assertion, 메모리 관리, 수학 라이브러리, 자료구조 & 알고리즘

> 자원 관리자
* 게임에 사용되는 리소스 (모델, 텍스쳐, 폰트, 스켈레톤, 애니메이션 지형 등)을 관리

> 렌더링 엔진
* 로우레벨 렌더러
    * 지오메트리를 가능한 빠르게 그리면서 다양한 방식을 지원
    * 화면의 가시성등의 추상적 문제에는 관여하지 않음
    * 그래픽 디바이스 인터페이스
        * 그래픽 SDK에서 그래픽 하드웨어를 찾고 초기화하고 렌더 표면 설정하는 것등을 담당하는 부분
        * 윈도우의 경우 메시지 루프와 렌더러의 연결이 필요
        * 윈도우 메시지(입력)가 도착하면 처리하고 나머지 시간에는 최대한 렌더러 루프를 돈다.
        * 키보드 메시지 루프와 스크린 업데이트 루프사이의 의존성이 생긴다.
    * 기타 구성 요소
        * 뷰포트에 대한 추상개념 지원
            * 카메라 월드 행렬, 3D 투영 매개변수 (fov, near plane, far plane) 
        * 머테리얼 시스템, 동적 조명 시스템
            * 그래픽 하드웨어와 쉐이더 상태를 관리
            * 지오메트리는 머테리얼과 결합되어 동적 조명에 영향을 받는다.
            * 머테리얼은 지오메트리의 텍스처와 디바이스 설정값, 정점 셰이더와 픽셀 셰이더의 상태를 나타내는 정보다.
            * 조명은 기본 단위를 그릴때 어떤 조명 계산 방식을 사용할지 나타낸다.
* 장면 그래프와 컬링(추려내기) 최적화
    * 로우레벨 렌더러는 걍 다그림 (후면 컬링과 카메라 절두체 컬링 제외)
    * 시야 결정을 통해 그릴 부분을 줄이는 일은 상위 계층에서 담당한다.
    * 보일 가능성이 있는 집합(PVS)을 빠르게 찾아내기
        * 공간 분할 (BSP트리, 옥트리, kd트리) 사용
        * 장면 그래프라고 부르기도 하는데 이건 그냥 자료구조
    * 포탈이나 차폐를 이용한 추려내기
    * 로우레벨 렌더러와 독립적으로 PVS을 잘 찾아내는것이 목표
* 시각 효과
    * 파티클, 데칼, 조명매핑, 환경매핑, 동적 그림자
    * post process
        * HDR, FSAA, 색교정, 색옮김, 채도 조정
    * 파티클과 데칼은 직접 로우레벨 렌더링에 입력을 주는 경우가 많다.
    * 조명 매핑, 환경매핑, 그림자는 렌더링 엔진 안에서 처리한다.
    * 포스트 프로세스는 렌더링 결과물로 처리할수도 있다.
* 전단부
    * 3d 그래픽 위에 덧씌워지는 2D그래픽
    * HUD, UI 등등
    * 2d화면 텍스처를 입힌 사각형을 직교투영하기
    * 3d빌보드에 그리고 카메라에 붙이기
    * 미리 녹화된 풀 스크린 비디오를 재생하는 FMV
    * 인게임 시네마틱은 3D로 재생, 플레이어 조작할 수도 있다.

> 프로파일링과 디버깅 툴
* 최적화를 위한 프로파일링, 메모리 분석 툴
* 필요한 구현
    * 코드의 소모 시간 측정
    * 게임 화면에서 실시간 프로파일링 수치 제공
    * 성능 값을 텍스트, 엑셀로 뽑아내기
    * 게임 엔진과 각 시스템이 사용중이 메모리 양을 측정하기
    * 메모리 사용량, 최고 사용량, 누수 통계등을 게임 종료될때 / 플레이 중 파일로 뽑아내기
    * 코드 안에서 디버그 메시지 출력하기, 필요한 항목마다 켜고 끄기 (로거)
    * 게임 플레이 녹화 재현하기
* 범용 디버깅 툴 - VTune, Quantify Purify, Bounds Checker

> 충돌과 물리
* 충돌 없이 제대로 게임하기 힘듬
* 사실적인 (강체) 역학 시뮬레이션이 필요할때도 있다.
* 충돌 감지되면 물리 로직이 동작하기에 둘은 연관이 있다.
* 외부에서 가져다 써라 PhysX

> 애니메이션
* 종류
    * 스프라이트 애니메이션
    * 리지드바디 하이라키 애니메이션
    * 스켈레탈 애니메이션
    * 정점 애니메이션
    * 모프타겟
* 스켈레탈 에니메이션을 많이씀 - 본 움직여서 자연스러운 움직임 구현
* 뼈대 메시 렌더링과 애니메이션은 깊은 관련 *스키닝
    * 애니메이션이 관절을 특정 포즈로 위치시킴
    * 관절의 위치가 렌더링 엔진으로 전달
    * 각 정점에 대한 행렬 변환으로 최정 정점위치를 계산

> 휴먼 인터페이스 장치 (HUD)
* 사용자 입력받기
* 키마, 조이패드, 기타 등등
* 플레이어에게 출력을 보내기도한다 (진동 소리등)
* 플렛폼마다 다른 하드웨어 정보를 상위 컨트롤에서 분리시키는것도 중요
* 하드웨어의 신호를 게임 규칙에 맞게 해석
* 입력의 민감도를 조절 
    * 데드존, 버튼 눌림 초기화, 버튼 업 다운 감지, 가속도계 입력 해석
* 코드(여러 버튼 동시 입력), 연타, 제스쳐등의 감지

> 오디오
* 오디오도 중요함 열심히 해라

> 멀티플레이 & 네트워킹
* 분류
    * 단일 스크린 멀티 플레이어: 스메시 브라더스
    * 분할 화면 멀티 플레이어: 플레이어별 화면 분할
    * 네트워크 멀티플레이어: 스타 네트워크 플레이
    * MMOG: 와우
* 멀티 게임 디자인은 싱글과 많이 다름
* 서버 안에 클라 하나 넣는 방법도 있음 (client on top of server)

> 게임 플레이 기반 시스템
* 게임 플레이: 게임내 행동, 규칙, 캐릭터 능력, 플레이어의 목표 및 목적
* 구현을 위해 스크립트 언어를 제공하기도 함
* 게임 플레이 기반 계층: 엔진의 로우레벨과 게임플레이 사이의 매개하는 계층
* 게임 월드와 객체 모델
    * 게임 월드에 속하는 여러 구성물들은 객체 지향적 방법으로 모델링 됨
    * 지형, 배경, 길, 동적인 물체, 플레이어 캐릭터, NPC, 무기, 발사체, 탈것, 빛, 카메라, 등등
    * 소프트웨어 객체모델과 관련
        * 언어가 뭔가
        * 클래스 구조는 뭔가 (수직적? 수평적?)
        * 템플릿 디자인 쓸거냐? 전통적 다형성?
        * 객체 접근 방식은? (포인터, 스마트포인터, 핸들)
        * 서로 다른 객체 구분 방식은? (물리적 주소, 이름, GUID)
        * 객체 수명 관리?
        * 시간의 흐름에 따른 상태 관리 방법은?
* 이벤트 시스템
    * 객체간 소통방식중 하나
    * 보내는 정보를 구조체에 담아서 이벤트 핸들러를 호출
    * 받은 이벤트를 큐에 담아서 나중에 처리할 수 있게 구현
* 스크립트 시스템
    * 게임 규칙과 콘텐츠를 쉽고 빠르게 개발하기 위한 방법
    * 컴파일, 빌드 하지 않아도 스크립트 수정만으로도 게임 로직 변경가능
* AI 기반 시스템
    * 지형지물을 피해서 정해진 지역을 돌아다님, 경로노드, 이동 볼륨 설정
    * 돌아다닐 수 있는 영역의 경계의 충돌정보를 간단하게 정의
    * 영역에 진입하고 진출하는 입구에 대한 정보, 시야개념
    * 길찾기 엔진
    * 시선 추적 및 인지
    * 판단에 필요한 객체 정보등 동적 충돌 회피에 사용하는 월드 모델

> 게임 특화 하부 시스템
* 플레이어 메카닉
* 카메라 시스템
* NPC 인공지능
* 무기 시스템
* 탈것 등등

### 툴과 리소스 파이프라인

> 디지털 콘텐츠 생성 도구(DCC)
* 리소스: 3d 메시, 텍스쳐 비트맵, 에니메이션 데이터, 오디오 파일
* DCC: 아티스트가 자원을 만들어내는 툴 
* DCC들은 각자 특정 자원을 만드는데 특화되어 있음
    * 마야 맥스: 3d 메시 & 에니메이션
    * 포토샵: 비트맵, 텍스처
    * 사운드 포지: 오디오클립
* 월드 제작은 자체 월드 제작 툴을 사용하는것이 일반적 (지형 생성등)
> 자원 다듬기 파이프라인
* DCC의 데이터를 가공해서 게임엔진에 적합한 형태로 변경해야한다.
* DCC는 제작을 위해 게임에 필요한 것 이상의 데이터를 가지고 있기 때문
* 로우데이터를 더 접근성이 뛰어난 표준 포멧으로 export
* 위 과정을 자원 다듬기 파이프라인이라고 한다.

> 3D 모델과 메시데이터
* 브러시 기하 형상
    * 평면 여러개로 구성된 볼록 입체 다각형의 모음
    * 게임 에디터로 바로 만들고 작업할 수 있다.
    * 빠르고 만들기 쉬워서 게임 디자이너가 프로토타입하기 좋다.
    * 충돌 볼륨역할을 할 수 있다.
    * 복잡하게 만들기 힘들고 관절을 넣는등 애니메이션 작업하기 어렵다.
* 3D 모델(메시)
    * 메시: 삼각형과 정점으로 이루어진 하나의 3D 형태
    * 복잡한 형태를 구현하는데 뛰어나다
    * 한개 이상의 머테리얼이 연관된다.
    * 모델: 여러개의 메시와 에니메이션 및 기타 데이터가 혼합된 개체
    * 맥스 마야 ZBrush 등으로 만들어지고 엔진에서 세임에 사용하기 적합한 포멧으로 변환한다.

> 뼈대 에니메이션 데이터
* 스켈레탈 메시(스킨): 본 애니메이션을 위해 본에 연결되는 특수한 형태의 메시
* 정점마다 연결된 관절(조인트) 및 가중치 정보가 들어있다.
* 스켈레탈 메시의 구성요소: 메시, 본 하이라키, 기본 포즈, 본 애니메이션
* DCC에서 내보낼때 메시와 본은 같은 파일로 나온다
* 여러개의 메시가 같은 본을 공유하는 경우 본 데이터를 분리해 다른 파일로 뽑아내는 게 좋다.
* 애니메이션은 각각 서로 다른 데이터로 분리해서 메모리 효율을 증대시킬 수 있다.
* 본 애니메이션은 4*3 행렬의 모음으로 100여개가 넘는 관절을 초당 30회 이상 표현하기에 용량이 크다. 압축해서 저장하는것이 일반적이다.

> 오디오 데이터
* 오디오 클립은 종류와 정교함에 있어 다양한 형태를 갖는다
    * 모노, 스테레오, 5.1채널, 7.1 채널, 멀티 채널
* wav가 가장 널리 쓰이는 방식이고 xvag, vag도 쓰인다.
* 편의성, 접근성, 스트리밍 등의 분류로 나뉘어 저장된다.

> 파티클
* 리얼타임수준에 적합한 툴을 사용한다.
* 게임에서 어떻게 보일지 판단하기 어려운 경우가 있다.

> 게임 월드 데이터와 월드 에디터
* 상용엔진에서 훙륭한 월드 에디터가 구현되어있다.
* 만들기 어렵지만 잘만들어야 좋은 엔진이 될 수 있다.

> 툴 구조에 대한 접근 방식
* 툴은 독자적 소프트웨어일수도 있고 엔진의 하위계층을 공유할수도 있다
